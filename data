Показывает ститстику по сборке (https://webpack.github.io/analyse/)
webpack --json --profile>stats.json

/******************************************************************************/

// npm repo babel-loader - просмотреть исходним модуля

/******************************************************************************/

Динамически подгружаем файл, webpack выделит его в отдельный файл
require.ensure([<module name>], function(require){
    let module = require('./<module1>')
}, '<NAME>');

Можно без названия модулей, тогда webpack проанализирует содержимое и сам решит что делать
require.ensure([], function(require){
    let module = require('./<module2>')
}, '<NAME>');

Если указывается параметр <NAME>, то module1 и module2 поместятся в одну сборку.
Таким образом можно объеденять несколько модулей в одну сбороку.

Если не указывать, то module1 и module2 поместятся в разные две сборки.

/******************************************************************************/

Если подключать модули динамически,
require('./plugins/' + pluginName);

то webpack создаст дополнительный модуль context
в этот модуль он запишет все динамические модули, все это в одном файле
далее вызывая context('./plugins/' + pluginName) модуль будет возращать нужный модуль

Минус в том, что хотя файлы и реквайряться динамически,ю в сборке они все равно в одном большом файле

require("./template/" + name + ".jade");
Directory: ./template
Regular expression: /^.*\.jade$/

/******************************************************************************/

Отдельную точку сборки создает require.ensure

/******************************************************************************/

Можно явно вызвать модуль context
require.context(directory, useSubdirectories = false, regExp = /^\.\//)

/******************************************************************************/

Не забывать использывать
path.join(__dirname + '/frontend') вместо
__dirname + '/frontend'

/******************************************************************************/